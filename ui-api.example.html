<!-- The following should be possible in a manifold project -->

<!-- Enable tracing & debug BEFORE loading the module so internal instrumentation activates -->
<script>
	window.MF_TRACE = true; // verbose internal instrumentation
	window.MF_DEBUG = true; // lighter setProp logging
	console.log("[mf] tracing enabled");
	// Periodically show queued effect counts (simple poll)
	setInterval(() => {
		try {
			console.log("[mf][heartbeat]");
		} catch {}
	}, 5000);
</script>

<!-- View Transitions demo styles (only apply in supporting browsers) -->
<style>
	@supports (view-transition-name: none) {
		:root {
			view-transition-name: none;
		}
		/* Assign names to elements we want to animate */
		.vt-fade {
			view-transition-name: vt-fade;
		}
		.vt-item {
			view-transition-name: vt-item;
		}

		/* Timing + easing */
		::view-transition-old(vt-fade),
		::view-transition-new(vt-fade),
		::view-transition-old(vt-item),
		::view-transition-new(vt-item) {
			animation-duration: 220ms;
			animation-timing-function: ease;
		}

		/* Fade for conditionals/async */
		::view-transition-old(vt-fade) {
			animation-name: vt-fade-out;
		}
		::view-transition-new(vt-fade) {
			animation-name: vt-fade-in;
		}

		/* Slide+fade for list insert/remove */
		::view-transition-old(vt-item) {
			animation-name: vt-slide-out;
		}
		::view-transition-new(vt-item) {
			animation-name: vt-slide-in;
		}

		@keyframes vt-fade-in {
			from {
				opacity: 0;
			}
			to {
				opacity: 1;
			}
		}
		@keyframes vt-fade-out {
			from {
				opacity: 1;
			}
			to {
				opacity: 0;
			}
		}
		@keyframes vt-slide-in {
			from {
				opacity: 0;
				transform: translateY(6px);
			}
			to {
				opacity: 1;
				transform: translateY(0);
			}
		}
		@keyframes vt-slide-out {
			from {
				opacity: 1;
				transform: translateY(0);
			}
			to {
				opacity: 0;
				transform: translateY(-6px);
			}
		}
	}
</style>
<script type="module">
	import StateBuilder from "./dist/manifold.es.js";
	// Import example component registration (defines <x-user-card>)
	import "./examples/example-component.js";

	// Build once after DOM is ready so auto-registration can bind regions.
	const init = () => {
		const state = StateBuilder.create(
			{
				count: 10,
				count2: 4,
				items: [1, 2, 3],
				userId: 1,
				asyncToggle: true,
				user: "Ada",
			},
			{
				// Use `this` (bound to the state proxy) to avoid TDZ on outer `state`
				increment(value) {
					this.count += value ?? 1;
				},
				setCount2(v) {
					this.count2 = +v;
				},
				loadUser() {
					// Read reactive deps synchronously so :await tracks them and re-runs on change
					const { asyncToggle, userId } = this;
					return new Promise((resolve, reject) => {
						setTimeout(() => {
							if (asyncToggle)
								resolve({ id: userId, name: "Ada" });
							else reject(new Error("User load failed"));
						}, 2000);
					});
				},
			}
		)
			.derive("sum", (s) => s.count + s.count2)
			.derive("doubleCount", (s) => s.count * 2)
			.add("syncBackCount2", function (value) {
				this.count2 = +value;
				console.log("Synced back count2 to:", value, this.count2);
			})
			.build();
		// Expose for console poking in the demo
		window.demoState = state;
	};
	if (document.readyState === "loading")
		window.addEventListener("DOMContentLoaded", init);
	else init();
</script>

<div data-mf-register>
	<h2>Primary UI</h2>
	<p>The current count is: ${count}</p>
	<p>The second count is: ${count2}</p>
	<p>The sum of both counts is: ${sum}</p>
	<p>
		The double of count is: ${doubleCount}; the double of count 2 is:
		${count2 * 2}
	</p>

	<p class="vt-fade" :if="count >= 15">Count is 15 or more!</p>
	<p class="vt-fade" :elseif="count >= 10">Count is between 10 and 14!</p>
	<p class="vt-fade" :elseif="count === 9">Count is 9!</p>
	<p class="vt-fade" :else>Count is less than 10!</p>

	<button :onclick="count = count + 1">Increment Count</button>
	<button :onclick="count2 = count2 + 2">Increment Count2</button>
	<button :onclick="increment(5)">+5</button>
	<button
		:onclick="console.log('[mf][manual] count before', count); increment(5); console.log('[mf][manual] count after', count);"
	>
		+5 (trace)
	</button>

	<!-- Two-way binding shorthand (supported API) -->
	<label>Count 1: <input type="number" sync:value="count" /></label>
	<!-- Explicit sync via event + function -->
	<label>
		Count 2:
		<input
			type="number"
			:value="count2"
			:oninput="setCount2(event.target.value)"
		/>
	</label>

	<!-- Async demo: :await / :then / :catch chain -->
	<div>
		<button :onclick="asyncToggle = !asyncToggle;">
			Toggle Async Success (currently: ${asyncToggle ? 'success' :
			'fail'})
		</button>
		<p class="vt-fade" :await="loadUser()">Loading user...</p>
		<p class="vt-fade" :then="user">
			Loaded: ID=${user.id} Name=${user.name}
		</p>
		<p class="vt-fade" :catch="err">Error: ${err.message}</p>
	</div>

	<!-- Each loop with alias exposure -->
	<ul>
		<li class="vt-item" :each="items as item, idx">Item ${idx}: ${item}</li>
	</ul>
	<button :onclick="items = items.concat(items.length + 1)">Add Item</button>
	<button :onclick="items = items.slice(0, -1)">Remove Item</button>
	<button :onclick="items.push(items.length + 1)">Add Item (alt)</button>
	<button :onclick="items.pop()">Remove Item</button>
	<button :onclick="items[3] = 'Jake!'">Change 3</button>

	<section style="margin-top: 1em; padding: 0.5em; border: 1px dashed #888">
		<h4>Diagnostics</h4>
		<p>
			Open console to view [mf][...] logs. Use the special +5 (trace)
			button to force extra logging around the increment function call.
		</p>
	</section>
</div>

<!-- Example custom element template and usage -->
<template id="tpl-user-card">
	<div data-mf-register>
		<p class="vt-fade">Hello, ${user}!</p>
		<button :onclick="user = 'Grace'">Change to Grace</button>
	</div>
</template>

<!-- Using the custom element defined via examples/example-component.js -->
<x-user-card></x-user-card>
